# -*- coding: utf-8 -*-
"""Final_Project_Dogecoin_Price_Prediction

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Bb8OlqkMYEYBhhW2MHjeT-goQmdmIh70
"""

!pip install yfinance
!pip install yahoofinancials

#import the libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.metrics import mean_absolute_error as mae 
from sklearn.preprocessing import StandardScaler
import yfinance as yf
from yahoofinancials import YahooFinancials

#creating the dataframe to store data
df = yf.download('DOGE-USD', start= '2021-01-01', end= '2021-04-01', progress=False)

df.head()  #printing out the dataset

#storing the close price of crypto in a different variable and reshaping our datset 
series = df['Close'].values.reshape(-1,1)

#normalizing the data 

scaler = StandardScaler()      #creating a scalar with 0 mean and 1 standard deviation
scaler.fit(series[:len(series) // 2])      #fit close data to the scalar
series = scaler.transform(series).flatten()   #creating a 1d array of transformed scalar using .flatten command

T= 10
S =1
X= []
Y = []

for t in range(len(series) - T):
  x = series[t:t+T]
  X.append(x)
  y = series[t+T]
  Y.append(y)

#shape our dataframe
X = np.array(X).reshape(-1, T)
Y = np.array(Y)
N = len(X)
print("X.shape", X.shape, "Y.shape", Y.shape)

#creating a class for our Machine Learning model
class BaselineModel:
  def predict(self, X):
    return X[:, -1] #return the last value for each input sequence

#split the data to test data and train data
Xtrain, Ytrain = X[:-N//2], Y[:-N//2]
Xtest, Ytest = X[-N//2:], Y[-N//2:]

#creating a model variable that holds our baseline Model class

model = BaselineModel()
Ptrain = model.predict(Xtrain)
Ptest = model.predict(Xtest)

#reshaping the arrays and storing them into another variable and creating a 1D array with Numpy

Ytrain2 = scaler.inverse_transform(Ytrain.reshape(-1,1)).flatten()
Ytest2 = scaler.inverse_transform(Ytest.reshape(-1,1)).flatten()
Ptrain2 = scaler.inverse_transform(Ptrain.reshape(-1,1)).flatten()
Ptest2 = scaler.inverse_transform(Ptest.reshape(-1,1)).flatten()

#Forecasting the prediction data

forecast = []
input_ = Xtest[0]
while len(forecast) < len(Ytest):
  f = model.predict(input_.reshape(1,T))[0]
  forecast.append(f)
  #make a new input with the latest forecast
  input = np.roll(input_, -1)
  input_[-1] = f
plt.plot(Ytest, label = 'target')
plt.plot(forecast, label = 'prediction')
plt.legend()
plt.title("Right forecast")
plt.show()